# app/database.py

import asyncio
import logging
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, AsyncEngine
from sqlalchemy.orm import sessionmaker
from sqlalchemy import text
from contextlib import asynccontextmanager
from typing import AsyncGenerator

from app.config import settings
from app.models import Base

logger = logging.getLogger(__name__)


class DatabaseManager:
    def __init__(self):
        self.engine: AsyncEngine = None
        self.session_factory: sessionmaker = None

    async def initialize(self):
        """Initialize database connection with retries for robustness."""
        max_retries = 5
        retry_delay = 5  # seconds

        for attempt in range(max_retries):
            try:
                logger.info(f"Database connection attempt {attempt + 1}/{max_retries}...")
                
                self.engine = create_async_engine(
                    settings.database_url,
                    echo=settings.debug,
                    pool_pre_ping=True,
                    pool_size=10,
                    max_overflow=20,
                    pool_recycle=3600
                )

                # Create session factory
                self.session_factory = sessionmaker(
                    bind=self.engine,
                    class_=AsyncSession,
                    expire_on_commit=False
                )

                # Test connection and create tables
                async with self.engine.begin() as conn:
                    await conn.run_sync(Base.metadata.create_all)
                
                logger.info("✅ Database initialized successfully.")
                return  # Exit the function on success

            except Exception as e:
                logger.warning(f"Database connection attempt {attempt + 1} failed: {e}")
                if self.engine:
                    await self.engine.dispose()
                if attempt + 1 == max_retries:
                    logger.error("❌ All database connection attempts failed.")
                    raise
                logger.info(f"Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)

    async def close(self):
        """Close database connections."""
        if self.engine:
            await self.engine.dispose()
            logger.info("✅ Database connections closed.")

    async def health_check(self) -> bool:
        """
        Simple database health check without manual transaction management.
        
        This method relies on SQLAlchemy's automatic transaction handling
        to avoid the "transaction already begun" error.
        """
        if not self.engine or not self.session_factory:
            logger.error("❌ Database not initialized")
            return False
        
        try:
            # Simple approach: let SQLAlchemy handle transactions automatically
            async with self.session_factory() as session:
                # Execute a simple query - SQLAlchemy will handle the transaction
                result = await session.execute(text("SELECT 1"))
                success = result.scalar_one() == 1
                logger.debug("✅ Database health check passed" if success else "❌ Database health check failed")
                return success
                
        except Exception as e:
            logger.error(f"❌ Database health check failed: {e}")
            return False

    @asynccontextmanager
    async def get_session(self) -> AsyncGenerator[AsyncSession, None]:
        """Get database session with proper cleanup."""
        if not self.session_factory:
            raise RuntimeError("Database not initialized - call initialize() first")

        async with self.session_factory() as session:
            try:
                yield session
                await session.commit()
            except Exception as e:
                await session.rollback()
                logger.error(f"❌ Database session error: {e}", exc_info=True)
                raise
            finally:
                await session.close()


# Global database manager instance
db_manager = DatabaseManager()


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency for getting database session."""
    async with db_manager.get_session() as session:
        yield session


async def init_db():
    """Initialize database."""
    await db_manager.initialize()


async def close_db():
    """Close database."""
    await db_manager.close()


async def check_database_health():
    """
    Comprehensive database health check with detailed status information.
    """
    start_time = asyncio.get_event_loop().time()
    
    try:
        is_healthy = await db_manager.health_check()
        response_time = (asyncio.get_event_loop().time() - start_time) * 1000
        
        return {
            "status": "healthy" if is_healthy else "unhealthy",
            "response_time_ms": round(response_time, 2),
            "details": {
                "engine_initialized": db_manager.engine is not None,
                "session_factory_initialized": db_manager.session_factory is not None,
                "connection_test": "passed" if is_healthy else "failed"
            }
        }
    except Exception as e:
        response_time = (asyncio.get_event_loop().time() - start_time) * 1000
        logger.error(f"❌ Database health check error: {e}", exc_info=True)
        return {
            "status": "unhealthy",
            "response_time_ms": round(response_time, 2),
            "error": str(e),
            "details": {
                "engine_initialized": db_manager.engine is not None,
                "session_factory_initialized": db_manager.session_factory is not None,
                "connection_test": "error"
            }
        }



#!/bin/bash

# A robust script to start the City Service API and its dependencies.

# --- Colors for better output ---
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[1;33m'
COLOR_RED='\033[0;31m'
NC='\033[0m' # No Color

# --- Function to print messages ---
info() {
    echo -e "${COLOR_GREEN}[INFO] $1${NC}"
}

error() {
    echo -e "${COLOR_RED}[ERROR] $1${NC}"
}

# --- Step 1: Check for prerequisites and CSV file ---
info "Step 1: Checking for prerequisites..."

if ! command -v docker &> /dev/null; then
    error "Docker could not be found. Please install Docker."
    exit 1
fi
if ! command -v docker-compose &> /dev/null; then
    error "docker-compose could not be found. Please install docker-compose."
    exit 1
fi
if [ ! -f "country-code.csv" ]; then
    error "CSV file 'country-code.csv' not found in project root directory!"
    error "Please place your CSV file (with columns: Country Code, City) in the same directory as this script."
    exit 1
fi
info "Prerequisites are satisfied ✓"

# --- Step 2: Clean up previous runs ---
info "Step 2: Cleaning up previous Docker containers and volumes..."
if [ "$(docker-compose ps -q)" ]; then
    docker-compose down -v --remove-orphans
    info "Previous environment stopped and cleaned."
else
    info "No previous environment found. Skipping cleanup."
fi

# --- Step 3: Start all services using Docker Compose ---
info "Step 3: Starting all services (Postgres, Redis, Kafka, App)..."
docker-compose up --build -d
if [ $? -ne 0 ]; then
    error "docker-compose up command failed. Aborting."
    exit 1
fi
info "All services are starting up..."

# --- Step 4: Wait for services to be healthy ---
info "Step 4: Waiting for all services to become healthy..."

# Wait for PostgreSQL
echo "Waiting for PostgreSQL to be ready (will timeout after 60 seconds)..."
counter=0
while ! docker exec city_service_postgres pg_isready -U postgres -q; do
    if [ $counter -ge 30 ]; then error "PostgreSQL did not become ready in 60 seconds. Aborting." && exit 1; fi
    counter=$((counter+1)); printf "."; sleep 2
done
echo -e "\n${COLOR_GREEN}PostgreSQL is ready. ✓${NC}"

# Wait for Redis
echo "Waiting for Redis to be ready (will timeout after 60 seconds)..."
counter=0
while ! docker exec city_service_redis redis-cli ping | grep -q PONG; do
    if [ $counter -ge 30 ]; then error "Redis did not become ready in 60 seconds. Aborting." && exit 1; fi
    counter=$((counter+1)); printf "."; sleep 2
done
echo -e "\n${COLOR_GREEN}Redis is ready. ✓${NC}"

# Wait for Kafka Broker
echo "Waiting for Kafka to be ready (will timeout after 90 seconds)..."
counter=0
until docker-compose exec -T kafka kafka-topics --bootstrap-server localhost:9092 --list &>/dev/null; do
    if [ $counter -ge 45 ]; then error "Kafka did not become ready in 90 seconds. Aborting." && exit 1; fi
    counter=$((counter+1)); printf "."; sleep 2
done
echo -e "\n${COLOR_GREEN}Kafka is ready. ✓${NC}"

# --- Step 5: Load CSV Data into the Database ---
info "Step 5: Loading data from country-code.csv..."
# --- FIX: Execute the script as a module (-m) so it knows about the 'app' package ---
docker-compose exec -T app python -m scripts.load_csv_data
if [ $? -ne 0 ]; then
    error "Data loading script failed. Please check the output above."
    exit 1
fi
info "Data loaded successfully ✓"

# --- Step 6: Wait for FastAPI application to be ready ---
info "Step 6: Waiting for the City Service API to be healthy..."
counter=0
while ! curl -sf -o /dev/null http://localhost:8000/health; do
    if [ $counter -ge 30 ]; then
        error "The API service did not become healthy in 60 seconds. Aborting."
        error "Tip: Check the application logs with 'docker-compose logs app' for details."
        exit 1
    fi
    counter=$((counter+1)); printf "."; sleep 2
done
echo -e "\n${COLOR_GREEN}City Service API is healthy and running. ✓${NC}"

# --- Step 7: Run Automated API Tests ---
info "Step 7: Running automated API tests inside the container..."
docker-compose exec -T app python -m scripts.test_api
if [ $? -ne 0 ]; then
    error "API tests failed. Please check the output above for errors."
    exit 1
fi
info "All API tests passed successfully! ✓"

# --- Final Step: Display Access Information ---
info "======================================================"
info "            🚀 APPLICATION IS READY! 🚀"
info "======================================================"
info "API Documentation (Swagger): http://localhost:8000/docs"
info "Health Check:                http://localhost:8000/health"
info "Kafka UI:                    http://localhost:8080"
info "To view logs:                docker-compose logs -f"
info "To stop the services:        docker-compose down -v"
info "======================================================"

