# app/api/cities.py
import time, logging
from typing import List

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import func, delete

from app.database import get_db
from app.models import City
from app.schemas import (
    CityCreateRequest as CityCreate,
    CityResponse,
    CityCountryCodeResponse,
    CityListResponse,
    MetricsResponse,
)
from app.cache import get_cache, CacheManager
from app.kafka_logger import get_kafka_logger, KafkaLogger

log = logging.getLogger(__name__)
router = APIRouter()


@router.post("/", response_model=CityResponse, status_code=201)
async def create_or_update_city(
    body: CityCreate,
    db: AsyncSession = Depends(get_db),
    cache: CacheManager = Depends(get_cache),
):
    stmt = select(City).where(func.lower(City.name) == body.name.lower())
    existing = (await db.execute(stmt)).scalar_one_or_none()
    if existing:
        existing.country_code = body.country_code
        await db.commit()
        await cache.delete(f"city:{existing.name.lower()}")
        return existing

    new_city = City(name=body.name, country_code=body.country_code)
    db.add(new_city)
    await db.commit()
    return new_city


@router.get("/{city_name}/country-code", response_model=CityCountryCodeResponse)
async def get_country_code(
    city_name: str,
    db: AsyncSession = Depends(get_db),
    cache: CacheManager = Depends(get_cache),
    kafka: KafkaLogger = Depends(get_kafka_logger),
):
    start = time.time()
    key = f"city:{city_name.lower()}"
    cached = await cache.get(key)
    if cached:
        kafka.log_request(city_name, time.time() - start, True, 200)
        return {"country_code": cached}

    stmt = select(City).where(func.lower(City.name) == city_name.lower())
    city = (await db.execute(stmt)).scalar_one_or_none()
    if not city:
        kafka.log_request(city_name, time.time() - start, False, 404)
        raise HTTPException(404, "City not found")

    await cache.set(key, city.country_code)
    kafka.log_request(city_name, time.time() - start, False, 200)
    return {"country_code": city.country_code}


@router.get("/", response_model=CityListResponse)
async def list_cities(
    db: AsyncSession = Depends(get_db),
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
):
    offset = (page - 1) * per_page
    total = (await db.execute(select(func.count()).select_from(City))).scalar_one()
    cities = (
        await db.execute(select(City).offset(offset).limit(per_page))
    ).scalars().all()
    return {
        "cities": cities,
        "total": total,
        "page": page,
        "per_page": per_page,
        "total_pages": (total + per_page - 1) // per_page,
    }


@router.delete("/{city_name}", status_code=204)
async def delete_city(
    city_name: str,
    db: AsyncSession = Depends(get_db),
    cache: CacheManager = Depends(get_cache),
):
    res = await db.execute(
        delete(City).where(func.lower(City.name) == city_name.lower())
    )
    await db.commit()
    if res.rowcount == 0:
        raise HTTPException(404, "City not found")
    await cache.delete(f"city:{city_name.lower()}")


@router.get("/metrics", response_model=MetricsResponse, tags=["metrics"])
async def metrics(
    cache: CacheManager = Depends(get_cache),
    kafka: KafkaLogger = Depends(get_kafka_logger),
):
    stats = cache.get_stats()
    return {
        "cache_metrics": stats,
        "performance_metrics": {
            "total_requests": kafka.total_requests,
            "cache_hits": kafka.cache_hits,
            "cache_misses": kafka.total_requests - kafka.cache_hits,
            "cache_hit_percentage": (
                kafka.cache_hits / kafka.total_requests * 100
                if kafka.total_requests
                else 0
            ),
            "uptime_seconds": 0,
        },
    }
